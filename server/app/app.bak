package app

import (
	"fmt"
	"log"
	"net"
	"net/http"
	"net/rpc"
	"sync"
	"viewStampedReplication/server/clientrpc"
	log2 "viewStampedReplication/server/log"
	"viewStampedReplication/server/viewmanager"
	"viewStampedReplication/server/viewreplication"
)

var appImpl *Impl

type Service interface {
	Request(req *ClientRequest, res *ClientReply) error
}

type Impl struct {
	*viewmanager.Impl
	WorkQueue chan *clientrpc.WorkRequest
}

func GetImpl() *Impl {
	return appImpl
}

func (impl *Impl) Request(req *ClientRequest, res *ClientReply) error {
	req.LogRequest()
	if !impl.IsClusterStatusNormal() {
		res.Err = fmt.Errorf("invalid operation status of cluster: %s", impl.GetClusterStatus())
		return nil
	}
	if !impl.IsPrimary() {
		res.Err = fmt.Errorf("invalid operation status of host: %s", viewreplication.RoleBackup)
		return nil
	}

	clientState := impl.GetClientState(req.ClientId)
	if clientState == nil {
		clientState = impl.CreateClientState(req.ClientId)
	}
	lastResponse := clientState.LastResponse
	if lastResponse != nil {
		if req.RequestId < lastResponse.RequestId {
			res.Res = nil
			res.Err = fmt.Errorf("stale request id detected")
			return nil
		} else if req.RequestId == lastResponse.RequestId {
			res.Res = clientState.LastResponse
			log.Printf("Request already executed; req: %v, res: %v", req, res)
			return nil
		}
	}
	// Add request to queue to be processed in viewreplication package
	workReq := impl.BufferRequest(req)
	workReq.GetWG().Wait()
	*res = *(workReq.GetResult().(*ClientReply))
	return nil
}

func (impl *Impl) BufferRequest(req *ClientRequest) *clientrpc.WorkRequest {
	var wg sync.WaitGroup
	workReq := clientrpc.NewWorkRequest(req, &wg)
	impl.WorkQueue <- workReq
	wg.Add(1)
	return workReq
}

func (impl *Impl) ProcessClientRequests() {
	for {
		workReq := <-(impl.WorkQueue)
		req := workReq.GetRequest().(*ClientRequest)
		log.Printf("Received work request; req: %v", req)
		opId := impl.AdvanceOpId()
		op := impl.AppendOp(req, opId)

		impl.UpdateClientState(workReq)
		done := impl.SendPrepareMessages(req.ClientId, req.RequestId, op)
		impl.WaitForQuorum(done)
		result := op.Commit()
		impl.AdvanceCommitId()
		workRes := workReq.GetResult()
		// This should update the last client response in the client table as well (since we're dealing in pointers).
		workRes.(*viewreplication.OpResponse).Result = result
		workReq.GetWG().Done()
	}
}

func (impl *Impl) PrepareOk(req *PrepareOkRequest, res *clientrpc.EmptyResponse) error {
	if !impl.IsPrimary() {
		log.Printf("Not primary. Ignoring request; req: %v", req)
		return nil
	}
	for _, op := range impl.Ops {
		if op.OpId == req.OpId {
			op.Quorum[req.ReplicaId] = true
			if op.IsQuorumSatisfied() {
				result := op.Commit()
				impl.AdvanceCommitId()
				c := impl.Config.GetClient(op.Log.ClientId)
				resp := impl.Impl.UpdateClientState(op.Log.ClientId, op.Log.RequestId, result)
				reply := &ClientReply{
					Res: resp,
					Err: nil,
				}
				c.Do("Client.Reply", reply, &clientrpc.EmptyResponse{}, true)
			}
		}
	}
	return nil
}

func (impl *Impl) AppendOp(req *ClientRequest, opId int) log2.Operation {
	logMsg := log2.LogMessage{
		ClientId:  req.ClientId,
		RequestId: req.RequestId,
		Log:       req.Op,
	}
	return impl.Impl.AppendOp(opId, logMsg)
}

func (impl *Impl) UpdateClientState(workReq *clientrpc.WorkRequest) {
	cr, ok := workReq.GetRequest().(*ClientRequest)
	if !ok {
		log.Fatalf("WorkRequest is not of type ClientRequest; req: %v", workReq)
	}
	lastResponse := impl.Impl.UpdateClientState(cr.ClientId, cr.RequestId, nil)
	workReq.SetResult(lastResponse)
}

func (impl *Impl) WaitForQuorum(done chan *viewreplication.PrepareOkResponse) {
	var quorum int
	var res *viewreplication.PrepareOkResponse
	for quorum < impl.GetQuorumSize() {
		res = <-done
		if res != nil {
			res.LogResponse()
			quorum += 1
		}
	}
}

func GetApp() *Impl {
	return appImpl
}

func Init() {
	viewmanager.Init()
	appImpl = &Impl{
		Impl: viewmanager.GetImpl(),
		WorkQueue:       make(chan *clientrpc.WorkRequest, clientrpc.MaxRequests),
	}
	rpc.RegisterName("ViewStampedReplication", appImpl)
	log.Print("App initialization successful")
	go appImpl.ProcessClientRequests()
	rpc.HandleHTTP()
	listener, err := net.Listen("tcp", fmt.Sprintf(":%d", appImpl.Config.Self.GetPort()))
	if err != nil {
		log.Fatal("Listen error: ", err)
	}
	err = http.Serve(listener, nil)
	if err != nil {
		log.Fatal("Error serving: ", err)
	}
}
